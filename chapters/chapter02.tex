\providecommand{\main}{..}
\documentclass[../notes.tex]{subfiles}

\begin{document}
  \setcounter{chapter}{1}
  \chapter{Graphics Programming}
    \section{The Sierpinski Gasket}
      \begin{definition}{Sierpinski Gasket}
        The \concept{Sierpinski Gasket} is an object that can be defined recursively and randomly,
        but has properties that are not random.

        Suppose we start with three points in space.
        As long as the points are not collinear, they are the vertices of a unique triangle
        and also define a unique plane.
        Assume this plane is the plane $z = 0$ and that these points are $(x_1, y_1, 0)$,
        $(x_2, y_2, 0)$ and $(x_3, y_3, 0)$.
        The construction proceeds as:
        \begin{enumerate}
          \item Pick an initial point $\mathbf{p} = (x, y, 0)$ at random inside the triangle.
          \item \label{sierp:2} Select one of the three vertices at random.
          \item Find the point $\mathbf{q}$ halfway between $\mathbf{p}$ and the selected vertex.
          \item Display $\mathbf{q}$ by putting some sort of marker,
            such as a small circle,
            at the corresponding location on the display.
          \item Replace $\mathbf{p}$ with $\mathbf{q}$.
          \item Return to step \ref{sierp:2}.
        \end{enumerate}
      \end{definition}

      \begin{definition}{Immediate Mode Graphics}
        As vertices are generated, they are sent directly to the graphics processor
        for rendering on the display.

        Until recently, was the standard method for displaying graphics.
        A consequence is that there is no memory of the geometric data,
        so if we want to redisplay the scene, we have to go through the entire creation
        and display process again.
      \end{definition}

      \begin{definition}{Retained Mode Graphics}
        Compute all the points first and store them in a data structure.
        Then display all the points through a single function call.

        This approach avoids the overhead of sending small amounts of data to the graphics
        processor for each point we generate,
        at the cost of having to store all the data.
        Because the data are stored, we can redisplay the scene, by resending the stored data
        without having to regenerate it.

        Current GPUs allow us to store the generated data directly on the GPU,
        which avoids the bottleneck caused by transferring the data from the CPU to the GPU
        each time we wish to redisplay the scene.
      \end{definition}

    \section{Programming Two-Dimensional Applications}
      Two-dimensional graphics can be viewed as a special case of three-dimensional graphics.
      The 2D-plane is a subspace of 3D-space.

      A point in the plane $z = 0$ can be represented as $\mathbf{p} = (x, y, 0)$ in the 3D world,
      or as $\mathbf{p} = (x, y)$ in the 2D plane.

      \begin{sidenote}{Vertices}
        A \concept{vertex} is a position in space.
        We use vertices to specify the atomic geometric primitives that are recognized
        by out graphics system.

        The simplest geometric primitive is a \concept{point} in space,
        which is usually specified by a single vertex.
        Two vertices can specify a line segment.
        Three can specify a triangle or circle,
        and so on.
      \end{sidenote}

      \begin{definition}{Clip Coordinate System}
        A cube centred at the origin whose diagonal goes from $(-1, -1, -1)$ to $(1, 1, 1)$.

        Objects outside of this cube will be eliminated (or \concept{clipped}) and cannot appear
        on the display.

        The vertex shader uses transformations to convert geometric data
        specified in some coordinate system to a representation in clip~coordinates,
        and outputs this information to the rasterizer.
      \end{definition}

    \pagebreak

    \section[The WebGL Application Programming Interface] {\sectionmark{The WebGL API}The WebGL Application Programming Interface}
      \sectionmark{The WebGL API}
      Our basic model of a graphics package is a \concept{black box}:
      a system whose properties are described only by its inputs and outputs;
      we know nothing about its internal workings.

      \begin{sidenote}{Function Groups for a Graphics System API}
        $ $\vspace{-1em}
        \begin{descriptenum}[nosep]
          \item[Primitive Functions] Define the low-level objects or atomic entities
            that our system can display.
            WebGL and OpenGL only support points, line segments, and triangles.
          \item[Attribute Functions] Allow us to perform operations to change the
            \concept{attributes} of a primitive.
            Attributes govern the way a primitive appears on the display.
          \item[Viewing Functions] Allow us to specify various views.
            WebGL and OpenGL do not provide any viewing functions,
            but rely on the use of transformations in the application or in the shaders.
          \item[Transformation Functions] Allows users to carry out transformations of objects,
            such as rotation, translation, and scaling.
            In WebGL, we carry out transformations by forming them in our applications,
            and then applying them either in the application or in the shaders.
          \item[Input Functions] Allows us to deal with input devices.
          \item[Control Functions] Enable use to communicate with the window system,
            to initialise our programs, and to deal with any errors that take place
            during the execution of our programs.
          \item[Query Functions] Provides additional information about the operating environment,
            such as camera parameters and values in the frame buffer.
        \end{descriptenum}
      \end{sidenote}

      \subsection{The Graphics Pipeline and State Machines}
        We can think of the entire graphics system as a \concept{state~machine}:
        a black box that contains a finite-state machine.
        The state machine has inputs that come from the application program.
        These inputs may change the state of the machine, or cause the machine to produce
        a visible output.

        One important consequence of the state machine view is that most parameters are
        \emph{persistent}: their values remain unchanged until we explicitly change them
        through functions that alter the state.
        Another consequence is that attributes are part of the state,
        rather than being bound to objects.

        \begin{sidenote}{Shader Functions}
          Part of the old textbook, not in the new.

          OpenGL functions are in a single library called GL.
          Shaders are written in the OpenGL Shading Language (GLSL),
          which has a separate specification.

          Functions that transfer data to the shaders have the following notation:
          \begin{center}
            \mintinline{text}{glSomeFunction*();}
          \end{center}
          where \texttt{*} can be interpreted as $nt$ or $ntv$, where $n$ signifies the number of dimensions,
          $t$ denotes the data type, and $v$ indicates that the variables are specified through
          a pointer to an array, rather than through an argument list.
        \end{sidenote}

      \subsection{Coordinate Systems}
        The advent of \concept{device-independent~graphics} freed application programmers
        from worrying about the details of input and output devices.
        The user's coordinate system become known as the \concept{world~coordinate~system},
        or the \concept{application (or object) coordinate system}.

        Units that the application program uses to specify vertex positions are called
        \concept{vertex~coordinates}, and will generally be the same as object or world coordinates.

        For raster devices, units on the display are called \concept{window coordinates}
        or \concept{screen coordinates}.

        At some point, the values in vertex coordinates must be mapped to window coordinates.
        The graphics system is responsible for this task,
        and the mapping is performed automatically as part of the rendering process.

\end{document}
